{"version":"1","records":[{"hierarchy":{"lvl1":"How to Reproduce This Experiment"},"type":"lvl1","url":"/guide","position":0},{"hierarchy":{"lvl1":"How to Reproduce This Experiment"},"content":"","type":"content","url":"/guide","position":1},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step-by-Step Guide"},"type":"lvl2","url":"/guide#step-by-step-guide","position":2},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step-by-Step Guide"},"content":"Follow these steps to reproduce the decompilation analysis on your own system.","type":"content","url":"/guide#step-by-step-guide","position":3},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Prerequisites","lvl2":"Step-by-Step Guide"},"type":"lvl3","url":"/guide#prerequisites","position":4},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Prerequisites","lvl2":"Step-by-Step Guide"},"content":"Required Tools\n\nGCC compiler (any recent version)\n\nText editor (VSCode, vim, etc.)\n\nWeb browser\n\nInternet connection for Dogbolt\n\nOptional Tools\n\nGit (for version control)\n\nobjdump (for assembly inspection)\n\nGhidra (for local decompilation)","type":"content","url":"/guide#prerequisites","position":5},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 1: Save the Source Code"},"type":"lvl2","url":"/guide#step-1-save-the-source-code","position":6},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 1: Save the Source Code"},"content":"Tip\n\nDownload or copy the complete source code from the \n\nsource code page.\n\nüõ† Save the source code as experiment.c:#include <stdio.h>\n#include <stdlib.h>\n\n// Function for Fibonacci sequence\nint calculate_fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2);\n}\n\n// Function with loop and local variables to compute sum of a given array\nint sum_array(int *arr, int size) {\n    int sum = 0;\n    int i;\n    \n    for (i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    \n    return sum;\n}\n\n// ... (rest of code - see source.md)","type":"content","url":"/guide#step-1-save-the-source-code","position":7},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 2: Compile with Different Optimizations"},"type":"lvl2","url":"/guide#step-2-compile-with-different-optimizations","position":8},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 2: Compile with Different Optimizations"},"content":"üõ† Open your terminal and navigate to the directory containing experiment.c:cd /path/to/your/experiment\n\nüõ† Compile with three different optimization levels:# No optimization - easiest to decompile\ngcc -O0 experiment.c -o experiment_O0\n\n# Moderate optimization\ngcc -O2 experiment.c -o experiment_O2\n\n# Aggressive optimization - hardest to decompile\ngcc -O3 experiment.c -o experiment_O3\n\nNote\n\nThe -O0, -O2, and -O3 flags control how aggressively GCC optimizes your code. -O0 means no optimization, while -O3 applies the most aggressive optimizations.","type":"content","url":"/guide#step-2-compile-with-different-optimizations","position":9},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Optional: Generate Assembly Files","lvl2":"Step 2: Compile with Different Optimizations"},"type":"lvl3","url":"/guide#optional-generate-assembly-files","position":10},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Optional: Generate Assembly Files","lvl2":"Step 2: Compile with Different Optimizations"},"content":"üõ† Generate human-readable assembly for comparison:gcc -O0 -S experiment.c -o experiment_O0.s\ngcc -O2 -S experiment.c -o experiment_O2.s\ngcc -O3 -S experiment.c -o experiment_O3.s\n\nüõ† Compare assembly line counts:wc -l experiment_O*.s\n\nYou should see output similar to:  234 experiment_O0.s\n  392 experiment_O2.s\n  454 experiment_O3.s\n 1080 total","type":"content","url":"/guide#optional-generate-assembly-files","position":11},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 3: Visit Dogbolt"},"type":"lvl2","url":"/guide#step-3-visit-dogbolt","position":12},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 3: Visit Dogbolt"},"content":"Important\n\nDogbolt is an online decompiler aggregator that lets you compare results from multiple decompilers including Ghidra, IDA, Binary Ninja, and more.\n\nüõ† Open your web browser and navigate to:https://dogbolt.org","type":"content","url":"/guide#step-3-visit-dogbolt","position":13},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 4: Upload and Decompile Each Binary"},"type":"lvl2","url":"/guide#step-4-upload-and-decompile-each-binary","position":14},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 4: Upload and Decompile Each Binary"},"content":"","type":"content","url":"/guide#step-4-upload-and-decompile-each-binary","position":15},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Upload experiment_O0","lvl2":"Step 4: Upload and Decompile Each Binary"},"type":"lvl3","url":"/guide#upload-experiment-o0","position":16},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Upload experiment_O0","lvl2":"Step 4: Upload and Decompile Each Binary"},"content":"üõ† Click ‚ÄúUpload Binary‚Äù on the Dogbolt homepage\n\nüõ† Select experiment_O0 from your file system\n\nüõ† Wait for decompilation (typically 30-60 seconds)\n\nüõ† Select ‚ÄúGhidra‚Äù from the decompiler options on the left sidebar\n\nTip\n\nYou can also select other decompilers like ‚ÄúHex-Rays‚Äù or ‚ÄúBinary Ninja‚Äù to compare results!","type":"content","url":"/guide#upload-experiment-o0","position":17},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Analyze the Output","lvl2":"Step 4: Upload and Decompile Each Binary"},"type":"lvl3","url":"/guide#analyze-the-output","position":18},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Analyze the Output","lvl2":"Step 4: Upload and Decompile Each Binary"},"content":"üõ† Find the main function in the decompiled code\n\nüõ† Compare with your original source:\n\nAre variable names the same?\n\nIs the control flow recognizable?\n\nAre functions still separate?\n\nüõ† Look for calculate_fibonacci and sum_array:\n\nDo they still exist as separate functions?\n\nCan you identify the algorithm?","type":"content","url":"/guide#analyze-the-output","position":19},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Repeat for O2 and O3","lvl2":"Step 4: Upload and Decompile Each Binary"},"type":"lvl3","url":"/guide#repeat-for-o2-and-o3","position":20},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Repeat for O2 and O3","lvl2":"Step 4: Upload and Decompile Each Binary"},"content":"üõ† Upload experiment_O2 and experiment_O3 separately\n\nüõ† Compare how optimizations transformed the code:\n\nWhich functions disappeared (inlined)?\n\nHow did loops change?\n\nIs the Fibonacci algorithm still recognizable?","type":"content","url":"/guide#repeat-for-o2-and-o3","position":21},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 5: Document Your Observations"},"type":"lvl2","url":"/guide#step-5-document-your-observations","position":22},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 5: Document Your Observations"},"content":"Create a comparison table like this:\n\nAspect\n\n-O0\n\n-O2\n\n-O3\n\nVariable names preserved?\n\n‚ùå No\n\n‚ùå No\n\n‚ùå No\n\nFunctions separate?\n\n‚úÖ Yes\n\n‚ö†Ô∏è Partially\n\n‚ùå No (inlined)\n\nFibonacci recognizable?\n\n‚úÖ Clear\n\n‚ö†Ô∏è Harder\n\n‚ùå Unrecognizable\n\nArray sum loop clear?\n\n‚úÖ Yes\n\n‚ö†Ô∏è Unrolled\n\n‚ùå Constant folded","type":"content","url":"/guide#step-5-document-your-observations","position":23},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 6: Deep Dive Analysis (Optional)"},"type":"lvl2","url":"/guide#step-6-deep-dive-analysis-optional","position":24},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Step 6: Deep Dive Analysis (Optional)"},"content":"","type":"content","url":"/guide#step-6-deep-dive-analysis-optional","position":25},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Using objdump for Assembly Inspection","lvl2":"Step 6: Deep Dive Analysis (Optional)"},"type":"lvl3","url":"/guide#using-objdump-for-assembly-inspection","position":26},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Using objdump for Assembly Inspection","lvl2":"Step 6: Deep Dive Analysis (Optional)"},"content":"üõ† View the assembly of a specific function:objdump -d experiment_O0 | grep -A 30 \"calculate_fibonacci\"","type":"content","url":"/guide#using-objdump-for-assembly-inspection","position":27},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Using Ghidra Locally","lvl2":"Step 6: Deep Dive Analysis (Optional)"},"type":"lvl3","url":"/guide#using-ghidra-locally","position":28},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Using Ghidra Locally","lvl2":"Step 6: Deep Dive Analysis (Optional)"},"content":"If you have \n\nGhidra installed:\n\nCreate a new project in Ghidra\n\nImport your binary: File ‚Üí Import File\n\nAnalyze with default options\n\nNavigate to the Functions list in the Symbol Tree\n\nCompare the Decompile view with your original source","type":"content","url":"/guide#using-ghidra-locally","position":29},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Compare Assembly Line Counts","lvl2":"Step 6: Deep Dive Analysis (Optional)"},"type":"lvl3","url":"/guide#compare-assembly-line-counts","position":30},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Compare Assembly Line Counts","lvl2":"Step 6: Deep Dive Analysis (Optional)"},"content":"üõ† View specific sections of assembly:# See how Fibonacci changes across optimization levels\ngrep -A 50 \"calculate_fibonacci:\" experiment_O0.s > fib_O0.txt\ngrep -A 50 \"calculate_fibonacci:\" experiment_O3.s > fib_O3.txt\ndiff fib_O0.txt fib_O3.txt","type":"content","url":"/guide#compare-assembly-line-counts","position":31},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"What to Look For"},"type":"lvl2","url":"/guide#what-to-look-for","position":32},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"What to Look For"},"content":"Easy to Recover ‚úÖ\n\nControl flow (if/else/loops)\n\nString literals\n\nNumeric constants\n\nFunction boundaries (-O0)\n\nBasic algorithms\n\nLost Forever ‚ùå\n\nVariable names\n\nComments\n\nType definitions (struct names)\n\nDeveloper reasoning\n\nCode organization","type":"content","url":"/guide#what-to-look-for","position":33},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Common Observations"},"type":"lvl2","url":"/guide#common-observations","position":34},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Common Observations"},"content":"","type":"content","url":"/guide#common-observations","position":35},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"At -O0 Level","lvl2":"Common Observations"},"type":"lvl3","url":"/guide#at-o0-level","position":36},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"At -O0 Level","lvl2":"Common Observations"},"content":"// Original\nint total = sum_array(numbers, array_size);\n\n// Decompiled - very similar!\nuint uVar2;\nuVar2 = sum_array(numbers, 10);","type":"content","url":"/guide#at-o0-level","position":37},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"At -O2/-O3 Level","lvl2":"Common Observations"},"type":"lvl3","url":"/guide#at-o2-o3-level","position":38},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"At -O2/-O3 Level","lvl2":"Common Observations"},"content":"// Original\nint total = sum_array(numbers, array_size);\n\n// Decompiled - computed at compile time!\n__printf_chk(1, \"Sum of array: %d\\n\", 0x37);\n\nWarning\n\nThe entire function call was eliminated and replaced with the hardcoded result 0x37 (55 in hex).","type":"content","url":"/guide#at-o2-o3-level","position":39},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Troubleshooting"},"type":"lvl2","url":"/guide#troubleshooting","position":40},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Troubleshooting"},"content":"","type":"content","url":"/guide#troubleshooting","position":41},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Binary Too Large for Dogbolt","lvl2":"Troubleshooting"},"type":"lvl3","url":"/guide#binary-too-large-for-dogbolt","position":42},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Binary Too Large for Dogbolt","lvl2":"Troubleshooting"},"content":"If your binary is too large, try:\n\nCompiling with -s to strip symbols: gcc -O0 -s experiment.c -o experiment_O0_stripped\n\nUsing a local decompiler instead (Ghidra, IDA)","type":"content","url":"/guide#binary-too-large-for-dogbolt","position":43},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Can‚Äôt Find Functions","lvl2":"Troubleshooting"},"type":"lvl3","url":"/guide#cant-find-functions","position":44},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Can‚Äôt Find Functions","lvl2":"Troubleshooting"},"content":"Make sure you compiled without stripping: don‚Äôt use -s flag\n\nLook for function addresses in the assembly output\n\nIn Ghidra, functions might be auto-named like FUN_00401234","type":"content","url":"/guide#cant-find-functions","position":45},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Decompiled Code Looks Wrong","lvl2":"Troubleshooting"},"type":"lvl3","url":"/guide#decompiled-code-looks-wrong","position":46},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl3":"Decompiled Code Looks Wrong","lvl2":"Troubleshooting"},"content":"Remember: decompilers are approximations, not perfect\n\nTry different decompilers on Dogbolt\n\nCompare with the assembly to verify logic","type":"content","url":"/guide#decompiled-code-looks-wrong","position":47},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Additional Experiments to Try"},"type":"lvl2","url":"/guide#additional-experiments-to-try","position":48},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Additional Experiments to Try"},"content":"Add more complex algorithms: Try quicksort, binary search, or linked lists\n\nUse different compilers: Compare GCC vs Clang vs MSVC\n\nTry obfuscation: Use tools like llvm-obfuscator\n\nStrip symbols: Compile with -s flag to see how it affects analysis\n\nAdd static analysis: Use cppcheck or clang-tidy on decompiled code","type":"content","url":"/guide#additional-experiments-to-try","position":49},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Resources"},"type":"lvl2","url":"/guide#resources","position":50},{"hierarchy":{"lvl1":"How to Reproduce This Experiment","lvl2":"Resources"},"content":"Dogbolt: \n\nhttps://dogbolt.org\n\nCompiler Explorer: \n\nhttps://godbolt.org (see assembly + source side-by-side)\n\nGhidra: \n\nhttps://‚Äãghidra‚Äã-sre‚Äã.org (full-featured reverse engineering)\n\nGCC Optimization Docs: \n\nhttps://‚Äãgcc‚Äã.gnu‚Äã.org‚Äã/onlinedocs‚Äã/gcc‚Äã/Optimize‚Äã-Options‚Äã.html\n\nTip\n\nOnce you‚Äôve completed the experiment, compare your findings with the main \n\nanalysis report!","type":"content","url":"/guide#resources","position":51},{"hierarchy":{"lvl1":"Decompilation Analysis Report"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Decompilation Analysis Report"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Overview"},"type":"lvl2","url":"/#overview","position":2},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Overview"},"content":"This experiment analyzes how compiler optimizations affect the ability to recover source code through decompilation. A simple C program was compiled with three optimization levels (-O0, -O2, -O3) and decompiled using Ghidra via \n\nDogbolt to compare what information can and cannot be reconstructed.\n\nImportant\n\nKey Finding: While control flow and logic are largely recoverable, semantic information like variable names, comments, and developer intent are permanently lost. Higher optimizations dramatically transform code structure.","type":"content","url":"/#overview","position":3},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Experimental Setup"},"type":"lvl2","url":"/#experimental-setup","position":4},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Experimental Setup"},"content":"","type":"content","url":"/#experimental-setup","position":5},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Source Code","lvl2":"Experimental Setup"},"type":"lvl3","url":"/#source-code","position":6},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Source Code","lvl2":"Experimental Setup"},"content":"A 65-line C program with:\n\nRecursive Fibonacci function\n\nArray sum with loop\n\nStruct manipulation with pointers\n\nConditional logic and I/O","type":"content","url":"/#source-code","position":7},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Compilation Commands","lvl2":"Experimental Setup"},"type":"lvl3","url":"/#compilation-commands","position":8},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Compilation Commands","lvl2":"Experimental Setup"},"content":"gcc -O0 experiment.c -o experiment_O0\ngcc -O2 experiment.c -o experiment_O2\ngcc -O3 experiment.c -o experiment_O3","type":"content","url":"/#compilation-commands","position":9},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Decompilation Tool","lvl2":"Experimental Setup"},"type":"lvl3","url":"/#decompilation-tool","position":10},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Decompilation Tool","lvl2":"Experimental Setup"},"content":"Dogbolt - Online decompiler aggregator\n\nUploaded each binary\n\nSelected Ghidra decompiler\n\nCompared output with original source","type":"content","url":"/#decompilation-tool","position":11},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Results Summary"},"type":"lvl2","url":"/#results-summary","position":12},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Results Summary"},"content":"","type":"content","url":"/#results-summary","position":13},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Assembly Line Counts","lvl2":"Results Summary"},"type":"lvl3","url":"/#assembly-line-counts","position":14},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Assembly Line Counts","lvl2":"Results Summary"},"content":"  234 experiment_O0.s\n  392 experiment_O2.s\n  454 experiment_O3.s\n\nNote\n\nSurprising result: Higher optimizations produced more assembly lines, not fewer. This is due to aggressive loop unrolling and inlining creating repetitive but efficient code patterns.","type":"content","url":"/#assembly-line-counts","position":15},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"What Was Successfully Recovered","lvl2":"Results Summary"},"type":"lvl3","url":"/#what-was-successfully-recovered","position":16},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"What Was Successfully Recovered","lvl2":"Results Summary"},"content":"‚úÖ Control Flow (All Levels)\n\nIf/else branches correctly identified\n\nLoop structures recognizable at -O0\n\nFunction call relationships preserved at -O0 and -O2\n\nString literals intact: \"Sum of array: %d\\n\", \"Point(%d,%d)\"\n\n‚úÖ Basic Data Types\n\nInteger operations clear\n\nPointer arithmetic identifiable\n\nStruct field offsets calculable (though not named)","type":"content","url":"/#what-was-successfully-recovered","position":17},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"What Was Lost Forever","lvl2":"Results Summary"},"type":"lvl3","url":"/#what-was-lost-forever","position":18},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"What Was Lost Forever","lvl2":"Results Summary"},"content":"‚ùå All Semantic Information\n\nVariable names: total ‚Üí uVar2, fib_result ‚Üí uVar3\n\nFunction names: Preserved only by symbol table\n\nComments: All removed during compilation\n\nType definitions: typedef struct { ... } Point; ‚Üí anonymous struct\n\n‚ùå Developer Intent\n\nVariable total becomes local_18 - purpose unclear\n\nFunction purposes must be inferred from behavior\n\nDesign patterns invisible\n\nOptimization rationale lost","type":"content","url":"/#what-was-lost-forever","position":19},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Detailed Analysis by Optimization Level"},"type":"lvl2","url":"/#detailed-analysis-by-optimization-level","position":20},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Detailed Analysis by Optimization Level"},"content":"","type":"content","url":"/#detailed-analysis-by-optimization-level","position":21},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"-O0: Most Recoverable","lvl2":"Detailed Analysis by Optimization Level"},"type":"lvl3","url":"/#id-o0-most-recoverable","position":22},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"-O0: Most Recoverable","lvl2":"Detailed Analysis by Optimization Level"},"content":"Fibonacci Function - Original:int calculate_fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2);\n}\n\nDecompiled:int calculate_fibonacci(int n) {\n  int iVar1;\n  int iVar2;\n  \n  if (1 < n) {\n    iVar1 = calculate_fibonacci(n + -1);\n    iVar2 = calculate_fibonacci(n + -2);\n    n = iVar2 + iVar1;\n  }\n  return n;\n}\n\nAnalysis:\n\nWhat Survived ‚úÖ\n\nAlgorithm clearly recognizable as Fibonacci\n\nRecursive structure preserved\n\nControl flow nearly identical\n\nWhat Was Lost ‚ùå\n\nVariable names changed to generic iVar1, iVar2\n\nSubtle logic inversion: n <= 1 became 1 < n","type":"content","url":"/#id-o0-most-recoverable","position":23},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Array Sum Comparison","lvl2":"Detailed Analysis by Optimization Level"},"type":"lvl3","url":"/#array-sum-comparison","position":24},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Array Sum Comparison","lvl2":"Detailed Analysis by Optimization Level"},"content":"Original:int sum_array(int *arr, int size) {\n    int sum = 0;\n    int i;\n    for (i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n\nDecompiled (-O0):int sum_array(int *arr, int size) {\n  int sum;\n  int i;\n  \n  sum = 0;\n  for (i = 0; i < size; i = i + 1) {\n    sum = sum + arr[i];\n  }\n  return sum;\n}\n\nTip\n\nNear-perfect recovery - only i++ became i = i + 1.","type":"content","url":"/#array-sum-comparison","position":25},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"-O2 & -O3: Aggressive Transformation"},"type":"lvl2","url":"/#id-o2-o3-aggressive-transformation","position":26},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"-O2 & -O3: Aggressive Transformation"},"content":"","type":"content","url":"/#id-o2-o3-aggressive-transformation","position":27},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Key Changes","lvl2":"-O2 & -O3: Aggressive Transformation"},"type":"lvl3","url":"/#key-changes","position":28},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Key Changes","lvl2":"-O2 & -O3: Aggressive Transformation"},"content":"Function Inlining: sum_array() and update_point() disappeared entirely - inlined into main()\n\nConstant Folding: Array sum computed at compile time as 0x37 (55 in decimal)\n\nLoop Unrolling: Simple for-loop became unrecognizable","type":"content","url":"/#key-changes","position":29},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Main Function - Critical Difference","lvl2":"-O2 & -O3: Aggressive Transformation"},"type":"lvl3","url":"/#main-function-critical-difference","position":30},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Main Function - Critical Difference","lvl2":"-O2 & -O3: Aggressive Transformation"},"content":"Original called sum_array(numbers, 10) and stored result in total.\n\nDecompiled at -O2/-O3:__printf_chk(1, \"Sum of array: %d\\n\", 0x37);  // Sum pre-calculated!\n\nWarning\n\nThe entire array and summation loop were eliminated. The compiler computed 1+2+...+10=55 at compile time and hardcoded 0x37 (55).","type":"content","url":"/#main-function-critical-difference","position":31},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Fibonacci at -O2/-O3 - Catastrophic Transformation","lvl2":"-O2 & -O3: Aggressive Transformation"},"type":"lvl3","url":"/#fibonacci-at-o2-o3-catastrophic-transformation","position":32},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Fibonacci at -O2/-O3 - Catastrophic Transformation","lvl2":"-O2 & -O3: Aggressive Transformation"},"content":"The simple recursive function became 100+ lines of deeply nested loops and bitwise operations:int calculate_fibonacci(int n) {\n  // ... initialization ...\n  if (1 < n) {\n    do {\n      local_64 = 0;\n      local_70 = local_74 + -1;\n      if (local_70 != 1) {\n        do {\n          local_60 = 0;\n          iVar1 = local_70 + -1;\n          if (iVar1 == 1) {\n            local_60 = 1;\n          }\n          else {\n            do {\n              // ... 80 more lines of nested loops ...\n              iVar7 = (iVar5 - 3U & 1) + iVar7;\n            } while (1 < iVar5);\n          }\n        } while (1 < local_70);\n      }\n    } while (1 < local_74);\n  }\n  return local_6c;\n}\n\nDanger\n\nAnalysis: The compiler transformed recursion into iteration with loop unrolling. While functionally equivalent, the algorithm is unrecognizable without extensive reverse engineering.","type":"content","url":"/#fibonacci-at-o2-o3-catastrophic-transformation","position":33},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Array Sum at -O2/-O3 - Loop Unrolling","lvl2":"-O2 & -O3: Aggressive Transformation"},"type":"lvl3","url":"/#array-sum-at-o2-o3-loop-unrolling","position":34},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Array Sum at -O2/-O3 - Loop Unrolling","lvl2":"-O2 & -O3: Aggressive Transformation"},"content":"// Original: simple for loop\n// Decompiled: 4-way unrolled loop\ndo {\n  iVar1 = *piVar5;\n  piVar2 = piVar5 + 1;\n  piVar3 = piVar5 + 2;\n  piVar4 = piVar5 + 3;\n  piVar5 = piVar5 + 4;\n  iVar7 = iVar7 + iVar1;\n  iVar8 = iVar8 + *piVar2;\n  iVar9 = iVar9 + *piVar3;\n  iVar10 = iVar10 + *piVar4;\n} while (piVar5 != arr + ...);\n\nProcesses 4 array elements per iteration for performance, but obscures the original simple loop.","type":"content","url":"/#array-sum-at-o2-o3-loop-unrolling","position":35},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Key Findings"},"type":"lvl2","url":"/#key-findings","position":36},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Key Findings"},"content":"","type":"content","url":"/#key-findings","position":37},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"The Semantic Gap","lvl2":"Key Findings"},"type":"lvl3","url":"/#the-semantic-gap","position":38},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"The Semantic Gap","lvl2":"Key Findings"},"content":"Even with perfect decompilation, there‚Äôs an unbridgeable semantic gap:\n\nRecoverable\n\nLost Forever\n\nWhat the code does\n\nWhy it does it\n\nControl flow logic\n\nDeveloper reasoning\n\nLiteral values\n\nVariable purposes\n\nFunction structure (-O0)\n\nDesign patterns\n\nBasic algorithms\n\nOptimization intent","type":"content","url":"/#the-semantic-gap","position":39},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Optimization Impact","lvl2":"Key Findings"},"type":"lvl3","url":"/#optimization-impact","position":40},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Optimization Impact","lvl2":"Key Findings"},"content":"Level\n\nRecoverability\n\nKey Changes\n\n-O0\n\n~85% structure\n\nMinimal transformation, clear logic\n\n-O2\n\n~50% structure\n\nInlining, constant folding, some unrolling\n\n-O3\n\n~30% structure\n\nAggressive transformation, unrecognizable algorithms","type":"content","url":"/#optimization-impact","position":41},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Example: Variable Name Loss","lvl2":"Key Findings"},"type":"lvl3","url":"/#example-variable-name-loss","position":42},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Example: Variable Name Loss","lvl2":"Key Findings"},"content":"// You write:\nint total = sum_array(numbers, array_size);\n\n// Decompiler sees:\nuint uVar2;\nuVar2 = sum_array(local_58, 10);\n\nImportant\n\nThe name total conveyed meaning - it‚Äôs a sum, a total. uVar2 is just a register placeholder. This semantic information is irrecoverable.","type":"content","url":"/#example-variable-name-loss","position":43},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Conclusions"},"type":"lvl2","url":"/#conclusions","position":44},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Conclusions"},"content":"","type":"content","url":"/#conclusions","position":45},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Can You Recover Source Code?","lvl2":"Conclusions"},"type":"lvl3","url":"/#can-you-recover-source-code","position":46},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"Can You Recover Source Code?","lvl2":"Conclusions"},"content":"Short answer: Partially, depending on optimization level.\n\n-O0: Yes, structure is ~85% intact. Readable with effort.\n\n-O2/-O3: Maybe 30-50%. Requires significant reverse engineering expertise.","type":"content","url":"/#can-you-recover-source-code","position":47},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"What This Means","lvl2":"Conclusions"},"type":"lvl3","url":"/#what-this-means","position":48},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl3":"What This Means","lvl2":"Conclusions"},"content":"For Proprietary Code Protection\n\nAlgorithms can be reverse-engineered, but require expertise. -O3 adds significant protection through obfuscation.\n\nFor Software Archaeology\n\nLost source code can be partially reconstructed, but will never match the original in clarity or intent.\n\nFor Reverse Engineering\n\nLower optimization levels are dramatically easier to analyze. A -O0 binary might take hours to understand; -O3 could take weeks.\n\nThe Bottom Line\n\nDecompilation recovers the what, rarely the why. The logic is there, but the story behind it is lost forever.","type":"content","url":"/#what-this-means","position":49},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Next Steps"},"type":"lvl2","url":"/#next-steps","position":50},{"hierarchy":{"lvl1":"Decompilation Analysis Report","lvl2":"Next Steps"},"content":"Follow the experiment guide to reproduce these results\n\nView the complete source code\n\nTry the \n\nDogbolt decompiler yourself\n\nExperiment Conducted: December 2024Tools: GCC, Dogbolt (Ghidra decompiler)Platform: Linux x86_64","type":"content","url":"/#next-steps","position":51},{"hierarchy":{"lvl1":"Complete Source Code"},"type":"lvl1","url":"/source","position":0},{"hierarchy":{"lvl1":"Complete Source Code"},"content":"","type":"content","url":"/source","position":1},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Overview"},"type":"lvl2","url":"/source#overview","position":2},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Overview"},"content":"This is the complete C source code used in the decompilation experiment. The program demonstrates various common programming patterns to test how well they survive compilation and decompilation at different optimization levels.","type":"content","url":"/source#overview","position":3},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Features Tested"},"type":"lvl2","url":"/source#features-tested","position":4},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Features Tested"},"content":"Recursive Functions\n\nThe Fibonacci function tests how recursion is preserved or transformed during optimization.\n\nArray Processing\n\nThe sum_array function tests loop handling and array manipulation.\n\nStruct Operations\n\nThe Point struct and update_point function test structure handling and pointer operations.\n\nControl Flow\n\nThe main function tests conditional statements and printf calls.","type":"content","url":"/source#features-tested","position":5},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Complete Source Code"},"type":"lvl2","url":"/source#complete-source-code","position":6},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Complete Source Code"},"content":"Save this as experiment.c:#include <stdio.h>\n#include <stdlib.h>\n\n// Function for Fibonacci sequence\nint calculate_fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2);\n}\n\n// Function with loop and local variables to compute sum of a given array\nint sum_array(int *arr, int size) {\n    int sum = 0;\n    int i;\n    \n    for (i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    \n    return sum;\n}\n\n// Function with struct and pointer manipulation\ntypedef struct {\n    int x;\n    int y;\n    char name[20];\n} Point;\n\nvoid update_point(Point *p, int new_x, int new_y) {\n    p->x = new_x;\n    p->y = new_y;\n    sprintf(p->name, \"Point(%d,%d)\", new_x, new_y);\n}\n\n//Main\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int array_size = 10;\n    \n    // Call sum function\n    int total = sum_array(numbers, array_size);\n    printf(\"Sum of array: %d\\n\", total);\n    \n    // Call fibonacci\n    int fib_result = calculate_fibonacci(10);\n    printf(\"Fibonacci(10): %d\\n\", fib_result);\n    \n    // Work with struct\n    Point my_point;\n    update_point(&my_point, 42, 84);\n    printf(\"Point: %s at (%d, %d)\\n\", my_point.name, my_point.x, my_point.y);\n    \n    // Comparing values test\n    if (total > fib_result) {\n        printf(\"Array sum is greater\\n\");\n    } else {\n        printf(\"Fibonacci is greater or equal\\n\");\n    }\n    \n    return 0;\n}","type":"content","url":"/source#complete-source-code","position":7},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Function Breakdown"},"type":"lvl2","url":"/source#function-breakdown","position":8},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Function Breakdown"},"content":"","type":"content","url":"/source#function-breakdown","position":9},{"hierarchy":{"lvl1":"Complete Source Code","lvl3":"calculate_fibonacci()","lvl2":"Function Breakdown"},"type":"lvl3","url":"/source#calculate-fibonacci","position":10},{"hierarchy":{"lvl1":"Complete Source Code","lvl3":"calculate_fibonacci()","lvl2":"Function Breakdown"},"content":"int calculate_fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    return calculate_fibonacci(n - 1) + calculate_fibonacci(n - 2);\n}\n\nWhat it tests:\n\nRecursive function calls\n\nBase case handling\n\nInteger arithmetic\n\nReturn value propagation\n\nExpected behavior at different optimization levels:\n\n-O0: Preserved as-is\n\n-O2/-O3: May be converted to iterative loops, heavily unrolled","type":"content","url":"/source#calculate-fibonacci","position":11},{"hierarchy":{"lvl1":"Complete Source Code","lvl3":"sum_array()","lvl2":"Function Breakdown"},"type":"lvl3","url":"/source#sum-array","position":12},{"hierarchy":{"lvl1":"Complete Source Code","lvl3":"sum_array()","lvl2":"Function Breakdown"},"content":"int sum_array(int *arr, int size) {\n    int sum = 0;\n    int i;\n    \n    for (i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    \n    return sum;\n}\n\nWhat it tests:\n\nFor loop handling\n\nArray indexing and pointer arithmetic\n\nLocal variable scoping\n\nAccumulator pattern\n\nExpected behavior at different optimization levels:\n\n-O0: Loop preserved exactly\n\n-O2: Loop may be unrolled 2-4 times\n\n-O3: May be completely eliminated if array is constant","type":"content","url":"/source#sum-array","position":13},{"hierarchy":{"lvl1":"Complete Source Code","lvl3":"update_point()","lvl2":"Function Breakdown"},"type":"lvl3","url":"/source#update-point","position":14},{"hierarchy":{"lvl1":"Complete Source Code","lvl3":"update_point()","lvl2":"Function Breakdown"},"content":"typedef struct {\n    int x;\n    int y;\n    char name[20];\n} Point;\n\nvoid update_point(Point *p, int new_x, int new_y) {\n    p->x = new_x;\n    p->y = new_y;\n    sprintf(p->name, \"Point(%d,%d)\", new_x, new_y);\n}\n\nWhat it tests:\n\nStruct definitions and field access\n\nPointer dereferencing\n\nString formatting with sprintf\n\nMultiple field updates\n\nExpected behavior at different optimization levels:\n\n-O0: Function boundary preserved, field accesses clear\n\n-O2/-O3: May be inlined, struct layout becomes offset calculations","type":"content","url":"/source#update-point","position":15},{"hierarchy":{"lvl1":"Complete Source Code","lvl3":"main()","lvl2":"Function Breakdown"},"type":"lvl3","url":"/source#main","position":16},{"hierarchy":{"lvl1":"Complete Source Code","lvl3":"main()","lvl2":"Function Breakdown"},"content":"int main() {\n    int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int array_size = 10;\n    \n    int total = sum_array(numbers, array_size);\n    printf(\"Sum of array: %d\\n\", total);\n    \n    int fib_result = calculate_fibonacci(10);\n    printf(\"Fibonacci(10): %d\\n\", fib_result);\n    \n    Point my_point;\n    update_point(&my_point, 42, 84);\n    printf(\"Point: %s at (%d, %d)\\n\", my_point.name, my_point.x, my_point.y);\n    \n    if (total > fib_result) {\n        printf(\"Array sum is greater\\n\");\n    } else {\n        printf(\"Fibonacci is greater or equal\\n\");\n    }\n    \n    return 0;\n}\n\nWhat it tests:\n\nStack-allocated arrays\n\nFunction call sequences\n\nMultiple variable declarations\n\nConditional branching\n\nStandard library calls (printf)\n\nExpected behavior at different optimization levels:\n\n-O0: All function calls visible, variables on stack\n\n-O2/-O3: Heavy inlining, constant folding (e.g., array sum becomes 0x37)","type":"content","url":"/source#main","position":17},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Expected Output"},"type":"lvl2","url":"/source#expected-output","position":18},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Expected Output"},"content":"When you compile and run this program, you should see:Sum of array: 55\nFibonacci(10): 55\nPoint: Point(42,84) at (42, 84)\nFibonacci is greater or equal\n\nNote\n\nThe array sum (1+2+...+10 = 55) equals Fibonacci(10) = 55, so the condition total > fib_result is false.","type":"content","url":"/source#expected-output","position":19},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Compilation Instructions"},"type":"lvl2","url":"/source#compilation-instructions","position":20},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"Compilation Instructions"},"content":"See the \n\nexperiment guide for detailed compilation instructions. Quick reference:# Compile without optimization\ngcc -O0 experiment.c -o experiment_O0\n\n# Compile with moderate optimization\ngcc -O2 experiment.c -o experiment_O2\n\n# Compile with aggressive optimization\ngcc -O3 experiment.c -o experiment_O3","type":"content","url":"/source#compilation-instructions","position":21},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"What Makes This a Good Test Case?"},"type":"lvl2","url":"/source#what-makes-this-a-good-test-case","position":22},{"hierarchy":{"lvl1":"Complete Source Code","lvl2":"What Makes This a Good Test Case?"},"content":"Diverse Patterns\n\nCombines recursion, iteration, structs, and I/O - common real-world patterns.\n\nMeasurable Results\n\nClear expected output makes it easy to verify correctness after optimization.\n\nOptimization-Friendly\n\nContains opportunities for constant folding, inlining, and loop unrolling.\n\nCompact Size\n\nSmall enough to analyze manually but complex enough to show interesting transformations.","type":"content","url":"/source#what-makes-this-a-good-test-case","position":23}]}